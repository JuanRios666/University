<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Banco de Pruebas Motor DC: Control_MCU/Control_MCU.ino File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Banco de Pruebas Motor DC<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">Banco de pruebas para un motor DC, en miras a usarlo como motor de Dron</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_0e5d6298faff7205c774c0bb832b4ce2.html">Control_MCU</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Control_MCU.ino File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;String.h&gt;</code><br />
<code>#include &quot;HX711.h&quot;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;Arduino.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4fc01d736fe50cf5b977f755b675f11d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_control___m_c_u_8ino.html#a4fc01d736fe50cf5b977f755b675f11d">setup</a> ()</td></tr>
<tr class="separator:a4fc01d736fe50cf5b977f755b675f11d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe461d27b9c48d5921c00d521181f12f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_control___m_c_u_8ino.html#afe461d27b9c48d5921c00d521181f12f">loop</a> ()</td></tr>
<tr class="separator:afe461d27b9c48d5921c00d521181f12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeaca349418e0f1d7ac6de05cf57558f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_control___m_c_u_8ino.html#adeaca349418e0f1d7ac6de05cf57558f">check_temperatura</a> ()</td></tr>
<tr class="separator:adeaca349418e0f1d7ac6de05cf57558f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8afabad3a8b07d94fe7b9e9cefca94e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_control___m_c_u_8ino.html#a8afabad3a8b07d94fe7b9e9cefca94e3">check_rpm</a> (uint32_t <a class="el" href="_control___m_c_u_8ino.html#ac23ec0394ccf6780857d5fce4ec23150">muestreo</a>)</td></tr>
<tr class="separator:a8afabad3a8b07d94fe7b9e9cefca94e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901edd07d00e77e2b629a8e9987d595b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_control___m_c_u_8ino.html#a901edd07d00e77e2b629a8e9987d595b">check_corriente</a> ()</td></tr>
<tr class="separator:a901edd07d00e77e2b629a8e9987d595b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04799c558dcc5d231e1a4fae09949841"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_control___m_c_u_8ino.html#a04799c558dcc5d231e1a4fae09949841">check_empuje</a> ()</td></tr>
<tr class="separator:a04799c558dcc5d231e1a4fae09949841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16cc82fb968dcc6281cd3efc9bc2a982"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_control___m_c_u_8ino.html#a16cc82fb968dcc6281cd3efc9bc2a982">espera</a> (uint32_t valor)</td></tr>
<tr class="separator:a16cc82fb968dcc6281cd3efc9bc2a982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3bc62369f3dd8281daee0519d95532"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_control___m_c_u_8ino.html#abb3bc62369f3dd8281daee0519d95532">countPulse</a> ()</td></tr>
<tr class="separator:abb3bc62369f3dd8281daee0519d95532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78de6ee487b43e3f00e6b6a3972592ce"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_control___m_c_u_8ino.html#a78de6ee487b43e3f00e6b6a3972592ce">calc_average</a> (uint32_t(&amp;<a class="el" href="_control___m_c_u_8ino.html#a6a66d0064b763a1ab7852890c2c2c619">average</a>)[4][10], uint8_t *i, uint8_t *dut)</td></tr>
<tr class="separator:a78de6ee487b43e3f00e6b6a3972592ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4a432b701e6ebbfaf823cfff3994a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_control___m_c_u_8ino.html#a4d4a432b701e6ebbfaf823cfff3994a9">step</a> (uint32_t *period_step, uint8_t *paso, uint32_t *samples)</td></tr>
<tr class="separator:a4d4a432b701e6ebbfaf823cfff3994a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6a54a67ccfade9d413793fd31de2eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_control___m_c_u_8ino.html#a1d6a54a67ccfade9d413793fd31de2eb">ramp</a> (uint32_t *<a class="el" href="_control___m_c_u_8ino.html#a81b43df06332b4fef558297592bb7ff1">period</a>, uint32_t *samples)</td></tr>
<tr class="separator:a1d6a54a67ccfade9d413793fd31de2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23ec0394ccf6780857d5fce4ec23150"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_control___m_c_u_8ino.html#ac23ec0394ccf6780857d5fce4ec23150">muestreo</a> (uint32_t *samples)</td></tr>
<tr class="separator:ac23ec0394ccf6780857d5fce4ec23150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8982e36e76fb7a0600ece003e4631db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_control___m_c_u_8ino.html#ab8982e36e76fb7a0600ece003e4631db">command</a> ()</td></tr>
<tr class="separator:ab8982e36e76fb7a0600ece003e4631db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a06982ada3ef2c1e88fd64466f289d0a3"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_control___m_c_u_8ino.html#a06982ada3ef2c1e88fd64466f289d0a3">fuerzaPin</a> = 8</td></tr>
<tr class="separator:a06982ada3ef2c1e88fd64466f289d0a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62ad789f4b2a44550fb20a78dbd6292"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_control___m_c_u_8ino.html#af62ad789f4b2a44550fb20a78dbd6292">CLK</a> = 7</td></tr>
<tr class="separator:af62ad789f4b2a44550fb20a78dbd6292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0333caacf456c040703eefbcf23eadb4"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_control___m_c_u_8ino.html#a0333caacf456c040703eefbcf23eadb4">temperaturePin</a> = A0</td></tr>
<tr class="separator:a0333caacf456c040703eefbcf23eadb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272782961591e88243aaed7e343f5b4e"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_control___m_c_u_8ino.html#a272782961591e88243aaed7e343f5b4e">currentPin</a> = A1</td></tr>
<tr class="separator:a272782961591e88243aaed7e343f5b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9bf5a85e82acd5e86e8b5033bfb9b7"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_control___m_c_u_8ino.html#a3f9bf5a85e82acd5e86e8b5033bfb9b7">velocityPin</a> = 2</td></tr>
<tr class="separator:a3f9bf5a85e82acd5e86e8b5033bfb9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e192cd37aecbefe9b3537cb1f53d43"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_control___m_c_u_8ino.html#ab7e192cd37aecbefe9b3537cb1f53d43">pwmPin</a> = 5</td></tr>
<tr class="separator:ab7e192cd37aecbefe9b3537cb1f53d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b81f71be6f86bc436d6e9d87d34592b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_control___m_c_u_8ino.html#a4b81f71be6f86bc436d6e9d87d34592b">mode</a> = 1</td></tr>
<tr class="separator:a4b81f71be6f86bc436d6e9d87d34592b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe67bf20b858132be2baed07869a7c8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_control___m_c_u_8ino.html#acfe67bf20b858132be2baed07869a7c8">activate</a> = 0</td></tr>
<tr class="separator:acfe67bf20b858132be2baed07869a7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f078684998b83967d507d0f453f454"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_control___m_c_u_8ino.html#ab3f078684998b83967d507d0f453f454">verbose</a> = 1</td></tr>
<tr class="separator:ab3f078684998b83967d507d0f453f454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2eabb75c6075eadbc527a29ddccbd0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_control___m_c_u_8ino.html#a6c2eabb75c6075eadbc527a29ddccbd0">vel</a> = 0</td></tr>
<tr class="separator:a6c2eabb75c6075eadbc527a29ddccbd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde8fe839a7d33cb4b77834f89790e92"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_control___m_c_u_8ino.html#afde8fe839a7d33cb4b77834f89790e92">step_duty</a> = 10</td></tr>
<tr class="separator:afde8fe839a7d33cb4b77834f89790e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e308154720adf9a6bb431b2a62ed8c0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_control___m_c_u_8ino.html#a8e308154720adf9a6bb431b2a62ed8c0">t_sample</a> = 5</td></tr>
<tr class="separator:a8e308154720adf9a6bb431b2a62ed8c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b43df06332b4fef558297592bb7ff1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_control___m_c_u_8ino.html#a81b43df06332b4fef558297592bb7ff1">period</a> = 1000</td></tr>
<tr class="separator:a81b43df06332b4fef558297592bb7ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a61065e096d8a912a7e968b4960871"><td class="memItemLeft" align="right" valign="top">volatile unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_control___m_c_u_8ino.html#a88a61065e096d8a912a7e968b4960871">pulseCount</a> = 0</td></tr>
<tr class="separator:a88a61065e096d8a912a7e968b4960871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3221aa6cb53e42ea42f28d478cf7247d"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_control___m_c_u_8ino.html#a3221aa6cb53e42ea42f28d478cf7247d">temperatura</a> = 0</td></tr>
<tr class="separator:a3221aa6cb53e42ea42f28d478cf7247d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e0fb212808117263f6bfc6ee76501b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_control___m_c_u_8ino.html#a38e0fb212808117263f6bfc6ee76501b">corriente</a> = 0</td></tr>
<tr class="separator:a38e0fb212808117263f6bfc6ee76501b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e6af75a4f2ab622b72b765625bb3ba"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_control___m_c_u_8ino.html#ab5e6af75a4f2ab622b72b765625bb3ba">strong</a> = 0</td></tr>
<tr class="separator:ab5e6af75a4f2ab622b72b765625bb3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28e82ae69032cb4ad3ec3a0be3d7129"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_control___m_c_u_8ino.html#ab28e82ae69032cb4ad3ec3a0be3d7129">limit</a> = 1000</td></tr>
<tr class="separator:ab28e82ae69032cb4ad3ec3a0be3d7129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d50004e6484bf8dd1018caebccaa1ee"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_control___m_c_u_8ino.html#a8d50004e6484bf8dd1018caebccaa1ee">media_average</a> = 1</td></tr>
<tr class="separator:a8d50004e6484bf8dd1018caebccaa1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a66d0064b763a1ab7852890c2c2c619"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_control___m_c_u_8ino.html#a6a66d0064b763a1ab7852890c2c2c619">average</a> [4][10]</td></tr>
<tr class="separator:a6a66d0064b763a1ab7852890c2c2c619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648a5bf98e673a14e22349119b2ea365"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_control___m_c_u_8ino.html#a648a5bf98e673a14e22349119b2ea365">tabla</a> [40][5]</td></tr>
<tr class="separator:a648a5bf98e673a14e22349119b2ea365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce3421cf7e022cf7eb7f02c02cc9cd8"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_control___m_c_u_8ino.html#a1ce3421cf7e022cf7eb7f02c02cc9cd8">indice</a> = 0</td></tr>
<tr class="separator:a1ce3421cf7e022cf7eb7f02c02cc9cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d008637819fe1c0a8a663a5c13e4c3"><td class="memItemLeft" align="right" valign="top">HX711&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_control___m_c_u_8ino.html#a11d008637819fe1c0a8a663a5c13e4c3">sensorFuerza</a></td></tr>
<tr class="separator:a11d008637819fe1c0a8a663a5c13e4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a78de6ee487b43e3f00e6b6a3972592ce" name="a78de6ee487b43e3f00e6b6a3972592ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78de6ee487b43e3f00e6b6a3972592ce">&#9670;&#160;</a></span>calc_average()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t calc_average </td>
          <td>(</td>
          <td class="paramtype">uint32_t(&amp;)&#160;</td>
          <td class="paramname"><em>average</em>[4][10], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Función que calcula el promedio de los valores de una matriz, en este caso la matriz tiene tantas filas como variables, y tantas columnas como muestras. La matriz se recorre por sus columnas hasta el punto indicado por la variable media_average, la cual define la cantidad de muestras a promediar, por cada fila hay un resultado promedio resultado de sumar los valores de las columnas de esa fila y dividir por el valor de media_average. Además de promediar, esta función permite guardar el valor promediado en una tabla para ser mostrado al finalizar mediante comandos. Los datos se pueden guardar en caso de haber sido promediados o no. Esto lo define si la variable de media_average es mayor a uno, es decir se deben promediar valores. Los valores guardados por cada muestra se guardan en filas diferentes, hasta llenarse la tabla, una vez llena la tabla se reescriben los valores en la tabla, empezando de arriba hacia abajo.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">average</td><td>es una matriz de valores, con tantas filas como variables medidas y columnas como muestras </td></tr>
    <tr><td class="paramname">i</td><td>es un valor de indice que ayuda a conocer en que punto de la matriz estoy asignando un valor de muestra, una vez se alcance el valor de media se calcula el promedio de valores y se reinicia este indice. </td></tr>
    <tr><td class="paramname">dut</td><td>el cual es el valor del duty que debe guardarse y dicho valor no se promedia </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>i, el valor retornado es el valor del indice aumentado en uno, esto indica que la proxima vez que ingrese a guardar un valor se hará en la siguiente columna, esto con el objetivo de llevar la cuenta de en que punto debo hacer el promedio.</dd></dl>

</div>
</div>
<a id="a901edd07d00e77e2b629a8e9987d595b" name="a901edd07d00e77e2b629a8e9987d595b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a901edd07d00e77e2b629a8e9987d595b">&#9670;&#160;</a></span>check_corriente()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void check_corriente </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Función encargada de leer por el pin currentPin, el valor correspondiente a un valor analogo entre 0 y 1023 correspondiente a los voltios que caen sobre una resistencia en serie con el motor, aqui se hace la conversión a amperios y se asigna a la variable de corriente el valor leído. <br  />
</p>

</div>
</div>
<a id="a04799c558dcc5d231e1a4fae09949841" name="a04799c558dcc5d231e1a4fae09949841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04799c558dcc5d231e1a4fae09949841">&#9670;&#160;</a></span>check_empuje()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void check_empuje </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Función encargada de leer el valor de empuje con ayuda del la librería HX711, con la función preparada para tal fin "sensorFuerza.get_units()" se lee la fuerza ejercida en gramossobre la celda de carga y se asigna a la variable strong</p>

</div>
</div>
<a id="a8afabad3a8b07d94fe7b9e9cefca94e3" name="a8afabad3a8b07d94fe7b9e9cefca94e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8afabad3a8b07d94fe7b9e9cefca94e3">&#9670;&#160;</a></span>check_rpm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void check_rpm </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>muestreo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Función encargada de evaluar el valor de la velocidad, mediante interrupciones. Lo hace llamando la funcion <a class="el" href="_control___m_c_u_8ino.html#a16cc82fb968dcc6281cd3efc9bc2a982">espera()</a>, pasándole como argumento el valor del perido durante el cual se toman las interrupciones, detiene las interrupciones, para que dentro de espera se activen una vez se empiecen a contar las interupciones, luego al salir de la función se vuelven a activar. Vale resaltar que se reinician todas la variables de los sensores para evitar que si alguno no fuciona quede con un valor leido en una muestra anterior. Luego de asignar el valor a la velocidad en la funcion <a class="el" href="_control___m_c_u_8ino.html#a16cc82fb968dcc6281cd3efc9bc2a982">espera()</a>, se realiza la conversion a rpm, donde se tienen 2 aspas, por tanto el valor de la velocidad sera multiplicado por 30 (60segundos en un minuto divido dos aspas) y se multiplica este valor por 1 segundo en micros dividido el tiempo durante el cual se hallaron las interrupciones den microsegundos. Dicho valor para que no importa cual sea el valor de tiempo durante el cual se tomen las interrupciones. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">muestreo</td><td>variable que trae el valor en microsegundos durante el cual se toman las interrupciones y se leen valores de los sensores.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adeaca349418e0f1d7ac6de05cf57558f" name="adeaca349418e0f1d7ac6de05cf57558f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeaca349418e0f1d7ac6de05cf57558f">&#9670;&#160;</a></span>check_temperatura()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void check_temperatura </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Función encargada de leer por el pin temperaturePin, el valor correspondiente a un valor analogo entre 0 y 1023 correspondiente a lso voltios que otorga el sensor LM35, aqui se hace la conversión y se asigna a la variable de temperatura el valor leído. <br  />
</p>

</div>
</div>
<a id="ab8982e36e76fb7a0600ece003e4631db" name="ab8982e36e76fb7a0600ece003e4631db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8982e36e76fb7a0600ece003e4631db">&#9670;&#160;</a></span>command()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void command </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Función que lee los comandos que se escriben por consola serial. if(Serial. available) Verifica si la terminal esta activa y a la espera de algun comando, despues de esto recupera el dato escrito en consola y lo configura para que todo quede en mayúscula, luego evalua en una serie de condicionales si cumple alguno y dependiendo de esto, asigna valores a variables, o activa banderas, incia sistemas, reestablece valores a variables, o asigna valores nuevos a variable existentes.</p>
<p>Pide el comando de la terminal</p>
<p>define siempre mayuscula el comando del usuario</p>
<p>if(comand=="MODE STP") Realiza estimulo a través de escalones continuos del porcentaje seleccionado</p>
<p>if(comand=="MODE TRG") Realiza estimulo en forma triangular variando la señal de forma lineal de 0 a 100% y de 100 a 0%</p>
<p>if(comand=="PERIOD") Establece el tiempo de duración de los escalones en el modo STEP en milisegundos, y en el modo TRG por defecto son 500ms</p>
<p>if(comand=="FSAMPLE") Establece un nuevo valor de frecuencia de muestreo, la frecuencia por defecto son 200Hz</p>
<p>if(comand=="AVERAGE") Establece el numero de muestras que se promedian por un dato almacenado, el numero de muestras promedio es 1, sin promedio</p>
<p>if(comand=="MAXCURRENT") Establece un valor de corriente máximo que la prueba no debe superar, si lo hace el sistema se detiene, por defecto es 1 amperio</p>
<p>if(comand=="VERBOSE") Establece si durante un periodoo de captura los datos se transmiten inmediato a consola, apagado por defecto</p>
<p>if(comand=="VERBOSE") Establece si durante un periodoo de captura los datos se almacenan para enviarse si se usa el comando FDATA, encendido por defecto</p>
<p>if(comand=="STATE") Imprime el modo en el que se esta utilizando el sistema de banco de pruebas modo, estado, periodo, frecuencia, average, verbose, y max current</p>
<p>if(comand=="FDATA") Imprime una tabla con los datos que seleccionemos</p>
<p>if(comand=="STOP") Detiene el estimulo aplicado al motor, este es el estado por defecto con el estímulo desactivado</p>
<p>if(comand=="RESET")) Restablece los valores por defecto que se encuentran en el state.</p>
<p>Salto de linea</p>
<p>imprime &gt;&gt; en terminal</p>

</div>
</div>
<a id="abb3bc62369f3dd8281daee0519d95532" name="abb3bc62369f3dd8281daee0519d95532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb3bc62369f3dd8281daee0519d95532">&#9670;&#160;</a></span>countPulse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void countPulse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Función que se ejecuta cada vez que hay una interrupción, es decir un flanco de subida en el pin 2 del arduino </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ninguno</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>No retorna nada, solo modifica la variable global volatil pulseCount, la cual se incrementa en uno cada vez que hay una interrupción</dd></dl>

</div>
</div>
<a id="a16cc82fb968dcc6281cd3efc9bc2a982" name="a16cc82fb968dcc6281cd3efc9bc2a982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16cc82fb968dcc6281cd3efc9bc2a982">&#9670;&#160;</a></span>espera()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void espera </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>valor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Función que me permite esperar durante un tiempo para que se cuenten los pulsos proveniente de las interrupciones de las aspas sobre un sensor infrarrojo. Además se usa para que durante el tiempo que lee las interrupciones se lean las demás variables en 3 instante diferentes de tiempo, dando espacio suficiente para que el conversor ADC interno del arduino esté listo para ser usado en otro pin una vez se haya desocupado con la anterior variable. Esto se hace con ayuda de un timer inicial, equivalente al reloj del sistema y se le suman fracciones del tiempo que se esperará en total, además se usa una bandera entera para saber en que punto se lee cual variable, con el objetivo de solo leer una vez la variable cada tiempo total. Es decir solo en 3 momento se leen las variables, esto mejora el tiempo de ejecución y disminuye asi las pérdidas de tiempo en este loop, haciendo mas exactos los tiempos de muestreo.</p>
<p>Cada vez que se inicia se reinicia el valor que tenga la variable pulseCount, se activan las interrupciones, y durante el tiempo se leen las mismas, luego se apagan las interrupciones y se asigna el valor de los pulsos contados a la velocidad.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valor</td><td>variable de 32bits, la cual es un numero en microsegundos, el cual me indica el tiempo que se crea el loop para contar pulsos, y durante el cual se leen las demás variable una única vez en cada caso. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>No retorna, pero cada vez que hay una interrupción se llama la función <a class="el" href="_control___m_c_u_8ino.html#abb3bc62369f3dd8281daee0519d95532">countPulse()</a></dd></dl>
<p>contador &lt; Variable contador local, que me indica el tiempo actual + la cantidad de tiempo en us que se hace el loop</p>
<p>Desactivo interrupciones</p>

</div>
</div>
<a id="afe461d27b9c48d5921c00d521181f12f" name="afe461d27b9c48d5921c00d521181f12f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe461d27b9c48d5921c00d521181f12f">&#9670;&#160;</a></span>loop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void loop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Función que se ejecuta en loop infinito en el arduino, aqui el loop se pregunta constantemente que comandos ingresa el usuario, una vez ingresados los commandos cuando el sistema se activa con el booleano &lt;activate&gt; ingresa a la condicional que ejecuta la función correspondiente, ya sea en modo step, o en modo triangular. Una vez terminado de ejecutarse el comando, el sistema muestra un mensaje y se desactiva, esperando su póxima activación.</p>

</div>
</div>
<a id="ac23ec0394ccf6780857d5fce4ec23150" name="ac23ec0394ccf6780857d5fce4ec23150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac23ec0394ccf6780857d5fce4ec23150">&#9670;&#160;</a></span>muestreo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void muestreo </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>samples</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Función que realiza una muestra de las variables sensadas, llamando a la funcion <a class="el" href="_control___m_c_u_8ino.html#a8afabad3a8b07d94fe7b9e9cefca94e3">check_rpm()</a> y entregandole el valor del periodo en micros durante el cual se calcularán los valores. Después dependiendo de la variable booleana verbose muestra en consola las variables medidas o no.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">samples</td><td>variable tipo puntero cuya direccion apunta a un valor de 32bits con el valor en microsegundos durante el cual se hará la evaluación de los sensores.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d6a54a67ccfade9d413793fd31de2eb" name="a1d6a54a67ccfade9d413793fd31de2eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d6a54a67ccfade9d413793fd31de2eb">&#9670;&#160;</a></span>ramp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ramp </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Función que realiza un aumento lineal del duty de 0 a 100 y de 100 a 0, en un periodo establecido, y toma muestras cada que se cumple un periodo de muestreo. Esta función ejecuta dos loops, en cada caso es decir en subid de la rampa y en bajada, de manera similar a la funcion <a class="el" href="_control___m_c_u_8ino.html#a4d4a432b701e6ebbfaf823cfff3994a9">step()</a>, usa timer con el objetivo de saber en que punto se debe tomar la muestra. En este caso el loop interior se ejecuta mientras uno de los timer+ periodo del paso de duty sea mayor al reloj actual. Mientras esta condicion se cumple se ejcuta dentro del loop la condición de si otro timer + periodo de muestreo es menor al reloj actual, si esto es cierto quiere decir que se ha pasado por el periodo de muestreo entonces se llama a la función <a class="el" href="_control___m_c_u_8ino.html#ac23ec0394ccf6780857d5fce4ec23150">muestreo()</a>, seguida de calc_average, si es necesario hacer muestreo, aunque fue verificado experimentalmente que no es adecuado, debido a que los periodos de cambio de duty son muy cortos, por tanto promediar muestras equivale a mezclar muestras de un valor de duty con otro totalmente diferente. Luego de esto se reinicia el timer de esta condición para contar a partir de aqui el nuevo valor del periodo de muestreo que debe alcanzarse para tomar una nueva muestra.</p>
<p>En el loop externo, se evalua si se ha alcanzao el valor máximo de duty, en caso de hacerse se sale de este proceso y se pasa al siguiente el cual es similar, tan solo que en lugar de aumentar el duty en pasos de a 1% se decrementa. En este punto se evalúa si se ha superado la corriente en una de las muestras, deteniendo el sistema de inmediato y apagando el motor en caso de ser asi. En este loop se crea la variable de tiempo para evaluar cada cuanto aumentar el duty, es decir cada cuanto debe acabarse el loop interno para aumentar en un porcentaje el duty. Se hac eun mapeo para asignar valores entre 0 y 255 al pwmPin.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">period</td><td>Variable tipo apuntador cuya dirección guarda el valor en milisegundos para el tamaño del periodo total de ejecución de la rampa en ascenso y descenso </td></tr>
    <tr><td class="paramname">samples</td><td>Variable tipo apuntador cuya dirección guarda el valor en milisegundos del periodo de muesreto para tomar los datos, es decir frecuencia de muestreo</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4fc01d736fe50cf5b977f755b675f11d" name="a4fc01d736fe50cf5b977f755b675f11d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fc01d736fe50cf5b977f755b675f11d">&#9670;&#160;</a></span>setup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Se inicializa los pines de entrada y salida, como entradas se tiene los sensores de temperatura, velocidad(interrupciones), corriente(puerto analógico), y fuerza. Como salida se tiene el pin encargado de escribir de manera analógica un valor de pwm en el motor. Ademas se inicializa el monitor serial, para imprimir en consola y leer de la misma los comandos de usuario. Se inicializa la interrupción para el pin que cuenta las interrupciones de las aspas (velocidad), asignando una función encargada de ejecutarse cuando se presente un flanco de subida en este pin. Se inicializa la balanza y se le hace la tara, es decir se resta el valor de lo que tenga encima en ese momento, esta balanza mide el empuje en gramos del motor, además se escala al valor previamente calculado para que mida en gramos.</p>

</div>
</div>
<a id="a4d4a432b701e6ebbfaf823cfff3994a9" name="a4d4a432b701e6ebbfaf823cfff3994a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d4a432b701e6ebbfaf823cfff3994a9">&#9670;&#160;</a></span>step()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void step </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>period_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>paso</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Función que realiza cambios del duty aplicado al motor, durante un periodo de tiempo y toma los datos de las variables de interés en ciertos periodos. Esta función ejecuta dos loops, uno dentro de otro, el primero loop, es decir el mas interno se ejecuta cada vez que se alcanza el valor de un periodo de paso de duty, es decir mediante un timer en micros + el periodo en micros, se compara con el reloj en micros actual, y si dicho valor es superado por el reloj del sistema (micros()) entonces se evalúa si tomar una muestra, esta evaluacion se hace con ayuda de otra variable tipo timer + periodo de muestreo, aqui se evalua la condición de que dicho periodo de muestreo se ha alcanzado entonces se llama a la función <a class="el" href="_control___m_c_u_8ino.html#ac23ec0394ccf6780857d5fce4ec23150">muestreo()</a>. Luego se llama la funcion <a class="el" href="_control___m_c_u_8ino.html#a78de6ee487b43e3f00e6b6a3972592ce">calc_average()</a> para guardar los valores del muestreo o en caso de necesitar promediarse, se guardan en la matriz hasta que se cumpla con la cantidad de muestras para realizar el promedio. En este punto se reinicia la variable timer1 para asignarle el nuevo valor de tiempo y que espere hasta que se cumpla el nuevo periodo para tomar la siguiente muestra.</p>
<p>El segundo loop se ejecuta de manera similar al primero, la condición de terminación de este loop es alcanzar el máximo valor del duty, puesto que este loop incrementan en pasos el duty sumandole el valor en la direccion a la que apunta la varibale paso, cada vez que se cumple la condicion del anterior loop, es decir cada vez que se ha completado el periodo correspondiente a un paso. En este loop, se evalúa el duty de 0 a 100% y se asigna un valor al pin de salida pwmPin entre 0 y 255, el cual aumenta la velocidad del motor. En este loop tambien se crea la variable de tiempo que se debe alcanzar hasta el nuevo paso de duty, es decir el periodo en microsegundos que se cumple en el loop interno. Vale aclara que una vez tomada una muestra se debe evaluar si el corriente no se ha superado, por ello se evalua si el valor de la corriente se encuentra en los limites, de no hacer el sistema se interrupto aburptamente con un break, saliendo de los loops y apagando el motor. Al finalizar este proceso el motor se apaga puesto que se ha alacanzado el máximo duty, asi que no se puede dejar encendido.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">period_step</td><td>Variable tipo apuntador, cuya dirección guarda el valor en milisegundos para el tamaño del periodo del step </td></tr>
    <tr><td class="paramname">paso</td><td>Variable tipo apuntador cuya dirección guarda un valor entre 0 y 100 para el tamaño del duty aplicado al motor para variar la velocidad </td></tr>
    <tr><td class="paramname">samples</td><td>Variable tipo apuntador cuya dirección guardae el valor de cada cuantos microsegundos se debe tomar los datos, es decir frecuencia de muestreo</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="acfe67bf20b858132be2baed07869a7c8" name="acfe67bf20b858132be2baed07869a7c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe67bf20b858132be2baed07869a7c8">&#9670;&#160;</a></span>activate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool activate = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Booleano que indica si esta activo o no el sistema </p>

</div>
</div>
<a id="a6a66d0064b763a1ab7852890c2c2c619" name="a6a66d0064b763a1ab7852890c2c2c619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a66d0064b763a1ab7852890c2c2c619">&#9670;&#160;</a></span>average</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t average[4][10]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matriz que guarda los valor a promediar por cada variable, por ello son 4 filas, 4 variables medidas, máximo 10 valores se promedian </p>

</div>
</div>
<a id="af62ad789f4b2a44550fb20a78dbd6292" name="af62ad789f4b2a44550fb20a78dbd6292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af62ad789f4b2a44550fb20a78dbd6292">&#9670;&#160;</a></span>CLK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int CLK = 7</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pin digital de salida que actúa como reloj para la libreria que controla la medida de fuerza de empuja de la celda de carga </p>

</div>
</div>
<a id="a38e0fb212808117263f6bfc6ee76501b" name="a38e0fb212808117263f6bfc6ee76501b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38e0fb212808117263f6bfc6ee76501b">&#9670;&#160;</a></span>corriente</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float corriente = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Variable que guarda el valor de la corriente medida que consume el motor </p>

</div>
</div>
<a id="a272782961591e88243aaed7e343f5b4e" name="a272782961591e88243aaed7e343f5b4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a272782961591e88243aaed7e343f5b4e">&#9670;&#160;</a></span>currentPin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int currentPin = A1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pin analógico de entrada para la medida de la corriente consumida por el motor </p>

</div>
</div>
<a id="a06982ada3ef2c1e88fd64466f289d0a3" name="a06982ada3ef2c1e88fd64466f289d0a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06982ada3ef2c1e88fd64466f289d0a3">&#9670;&#160;</a></span>fuerzaPin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int fuerzaPin = 8</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>&lt; Se incluye libreria String para imprimir con formato por consola &lt; Se incluye librería HX711 para manipular la celda de carga con su converson analogo digital de 24 bits &lt; Se incluye libreria stdint para manejar variables tipo uint_t &lt; Se incluye libreria arduino para manejar variables tipo uint_t Pin digital de entrada por el cual se lee el valor de la fuerza de empuje medida </p>

</div>
</div>
<a id="a1ce3421cf7e022cf7eb7f02c02cc9cd8" name="a1ce3421cf7e022cf7eb7f02c02cc9cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ce3421cf7e022cf7eb7f02c02cc9cd8">&#9670;&#160;</a></span>indice</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t indice = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indice que recorre las posiciones de la matriz donde se guardan las mediciones de cada variable por cada muestra </p>

</div>
</div>
<a id="ab28e82ae69032cb4ad3ec3a0be3d7129" name="ab28e82ae69032cb4ad3ec3a0be3d7129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab28e82ae69032cb4ad3ec3a0be3d7129">&#9670;&#160;</a></span>limit</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t limit = 1000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Variable que establece el valor máximo de corriente que permite el sistema en miliamperios </p>

</div>
</div>
<a id="a8d50004e6484bf8dd1018caebccaa1ee" name="a8d50004e6484bf8dd1018caebccaa1ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d50004e6484bf8dd1018caebccaa1ee">&#9670;&#160;</a></span>media_average</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t media_average = 1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Variable que establece la cantidad de muestras que se promedian </p>

</div>
</div>
<a id="a4b81f71be6f86bc436d6e9d87d34592b" name="a4b81f71be6f86bc436d6e9d87d34592b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b81f71be6f86bc436d6e9d87d34592b">&#9670;&#160;</a></span>mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mode = 1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Booleano que escoge los dos modos de operación </p>

</div>
</div>
<a id="a81b43df06332b4fef558297592bb7ff1" name="a81b43df06332b4fef558297592bb7ff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81b43df06332b4fef558297592bb7ff1">&#9670;&#160;</a></span>period</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t period = 1000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Variable que guarda el periodo que dura un paso en modo STP, o todo el estimulo en modo TRG en ms </p>

</div>
</div>
<a id="a88a61065e096d8a912a7e968b4960871" name="a88a61065e096d8a912a7e968b4960871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a61065e096d8a912a7e968b4960871">&#9670;&#160;</a></span>pulseCount</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile unsigned long pulseCount = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Variable volátil para contar las interrupciones que generan las aspas al cruzar por el infrarrojo </p>

</div>
</div>
<a id="ab7e192cd37aecbefe9b3537cb1f53d43" name="ab7e192cd37aecbefe9b3537cb1f53d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7e192cd37aecbefe9b3537cb1f53d43">&#9670;&#160;</a></span>pwmPin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int pwmPin = 5</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pin digital de salida por donde sale la señal pwm para controlar la velocidad del motor </p>

</div>
</div>
<a id="a11d008637819fe1c0a8a663a5c13e4c3" name="a11d008637819fe1c0a8a663a5c13e4c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d008637819fe1c0a8a663a5c13e4c3">&#9670;&#160;</a></span>sensorFuerza</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HX711 sensorFuerza</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Se define el sensor de fuerza usando la libreria HX711 para leer los valores de fuerza medidos </p>

</div>
</div>
<a id="afde8fe839a7d33cb4b77834f89790e92" name="afde8fe839a7d33cb4b77834f89790e92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afde8fe839a7d33cb4b77834f89790e92">&#9670;&#160;</a></span>step_duty</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t step_duty = 10</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Variable que controla el valor del duty de la señal pwm de 0 a 100% </p>

</div>
</div>
<a id="ab5e6af75a4f2ab622b72b765625bb3ba" name="ab5e6af75a4f2ab622b72b765625bb3ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5e6af75a4f2ab622b72b765625bb3ba">&#9670;&#160;</a></span>strong</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float strong = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Variable que gaurda el valor del empuje medido por la celda de carga </p>

</div>
</div>
<a id="a8e308154720adf9a6bb431b2a62ed8c0" name="a8e308154720adf9a6bb431b2a62ed8c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e308154720adf9a6bb431b2a62ed8c0">&#9670;&#160;</a></span>t_sample</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t t_sample = 5</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Variable que guarda el periodo de muestreo en ms, por defecto son 200Hz = 5ms </p>

</div>
</div>
<a id="a648a5bf98e673a14e22349119b2ea365" name="a648a5bf98e673a14e22349119b2ea365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a648a5bf98e673a14e22349119b2ea365">&#9670;&#160;</a></span>tabla</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t tabla[40][5]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matriz que guarda los valores leidos en cada muestra, ya sea promediada o no para luego mostrarla como una tabla en consola </p>

</div>
</div>
<a id="a3221aa6cb53e42ea42f28d478cf7247d" name="a3221aa6cb53e42ea42f28d478cf7247d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3221aa6cb53e42ea42f28d478cf7247d">&#9670;&#160;</a></span>temperatura</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t temperatura = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Variable que guarda el valor de la temperatura medido por el sensor LM35 en grados </p>

</div>
</div>
<a id="a0333caacf456c040703eefbcf23eadb4" name="a0333caacf456c040703eefbcf23eadb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0333caacf456c040703eefbcf23eadb4">&#9670;&#160;</a></span>temperaturePin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int temperaturePin = A0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pin analógico de entrada de la variable temperatura </p>

</div>
</div>
<a id="a6c2eabb75c6075eadbc527a29ddccbd0" name="a6c2eabb75c6075eadbc527a29ddccbd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c2eabb75c6075eadbc527a29ddccbd0">&#9670;&#160;</a></span>vel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t vel = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Variable que guarda la velocidad en RPM </p>

</div>
</div>
<a id="a3f9bf5a85e82acd5e86e8b5033bfb9b7" name="a3f9bf5a85e82acd5e86e8b5033bfb9b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f9bf5a85e82acd5e86e8b5033bfb9b7">&#9670;&#160;</a></span>velocityPin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int velocityPin = 2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pin digital de entrada donde se conecta la señal de interrupción de las aspas del motor, para medir la velocidad </p>

</div>
</div>
<a id="ab3f078684998b83967d507d0f453f454" name="ab3f078684998b83967d507d0f453f454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f078684998b83967d507d0f453f454">&#9670;&#160;</a></span>verbose</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool verbose = 1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Booleano que indica si escribir todo en consola a medida que se ejecuta el sistema y se toman las muestras </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
